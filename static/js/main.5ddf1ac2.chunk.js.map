{"version":3,"sources":["interfaces/index.ts","components/TileComponent/TileComponent.tsx","components/BoardComponent/BoardComponent.tsx","utils/index.ts","services/game.ts","components/App/App.tsx","state/index.ts","serviceWorker.ts","index.tsx"],"names":["Direction","React","memo","style","onClick","className","BoardComponent","props","tileWidth","tileHeight","gap","rows","cols","onTileClick","board","slice","map","tile","index","top","left","bgLeft","bgTop","Math","floor","key","backgroundPosition","rand","min","max","random","DIRECTIONS","UP","DOWN","LEFT","RIGHT","createBoard","Array","fill","item","shuffle","iterationCount","emptyIndex","reduce","previousBoard","array","direction","length","getMovingTileIndex","moveTile","size","indexOutOfRange","tilePosition","emptyPosition","abs","canMoveTile","newBoard","positionToMove","emptyTile","calculatePosition","i","gameMachine","config","initial","context","moves","originalBoard","game","states","ready","on","target","actions","unsolved","MOVE","cond","internal","CLICK","solved","type","options","guards","isSolved","solvedBoard","b","every","SHUFFLE","assign","MOVE_BY_DIRECTION","event","MOVE_BY_INDEX","INCREMENT_MOVES","Machine","createMachine","NUM_TILES","App","useMachine","state","send","handleClick","useCallback","useEffect","listener","keyCode","getDirectionByKeyCode","window","addEventListener","removeEventListener","matches","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.5ddf1ac2.chunk.js","sourcesContent":["export enum Direction {\n  UP = 'up',\n  DOWN = 'down',\n  LEFT = 'left',\n  RIGHT = 'right',\n}\n\ntype Tuple<A, B> = [A, B];\n\nexport type BoardTile = Tuple<number, number>;\n\nexport type Board = Array<BoardTile>;\n","import React from 'react';\n\nimport './TileComponent.scss';\n\ninterface Props {\n  style?: React.CSSProperties;\n  onClick?: () => void;\n}\n\nconst TileComponent = ({ style, onClick }: Props) => (\n  <div className=\"tile\" onClick={onClick} style={style} />\n);\n\nexport default React.memo(TileComponent);\n","import React from 'react';\nimport { Board } from '../../interfaces';\nimport TileComponent from '../TileComponent/TileComponent';\n\nimport './BoardComponent.scss';\n\ninterface Props {\n  rows: number;\n  cols: number;\n  tileWidth: number;\n  tileHeight: number;\n  gap: number;\n  board: Board;\n  onTileClick: (index: number) => void;\n}\n\nconst BoardComponent = (props: Props) => {\n  const { tileWidth, tileHeight, gap, rows, cols, onTileClick } = props;\n\n  return (\n    <div className=\"board\">\n      {props.board.slice(0, -1).map((tile, index) => {\n        const top = tile[0] * tileWidth + gap;\n        const left = tile[1] * tileHeight + gap;\n        const bgLeft = (index % rows) * tileWidth + gap;\n        const bgTop = Math.floor(index / cols) * tileHeight + gap;\n\n        const handleClick = () => {\n          onTileClick && onTileClick(index);\n        };\n\n        return (\n          <TileComponent\n            key={index}\n            onClick={handleClick}\n            style={{\n              top,\n              left,\n              backgroundPosition: `-${bgLeft}px -${bgTop}px`,\n            }}\n          />\n        );\n      })}\n    </div>\n  );\n};\n\nexport default BoardComponent;\n","import { Direction } from '../interfaces';\n\nexport const rand = (min: number, max: number) => {\n  const rand = min + Math.random() * (max + 1 - min);\n  return Math.floor(rand);\n};\n\nexport const getRandomArrayElement = function <T>(array: Array<T>): T {\n  return array[rand(0, array.length - 1)];\n};\n\nexport const getDirectionByKeyCode = (keyCode: number): Direction | null => {\n  switch (keyCode) {\n    case 37:\n      return Direction.LEFT;\n    case 38:\n      return Direction.UP;\n    case 39:\n      return Direction.RIGHT;\n    case 40:\n      return Direction.DOWN;\n    default:\n      return null;\n  }\n};\n","import { Board, BoardTile, Direction } from '../interfaces';\nimport { getRandomArrayElement } from '../utils';\n\nconst DIRECTIONS = [\n  Direction.UP,\n  Direction.DOWN,\n  Direction.LEFT,\n  Direction.RIGHT,\n];\n\nexport const createBoard = (rows: number, cols: number): Board =>\n  new Array(rows * cols)\n    .fill(0)\n    .map((item: number, index) => [Math.floor(index / rows), index % cols]);\n\nexport const shuffle = (\n  board: Board,\n  iterationCount: number,\n  emptyIndex: number,\n) =>\n  new Array(iterationCount).fill(0).reduce((previousBoard) => {\n    const direction = getRandomArrayElement(DIRECTIONS);\n\n    const index = getMovingTileIndex(previousBoard, direction, emptyIndex);\n\n    return moveTile(previousBoard, index, emptyIndex);\n  }, board);\n\nexport const size = (board: Board) => board.length;\n\nexport const areEqual = (a: Board, b: Board) =>\n  a.every((tile, index) => tile[0] === b[index][0] && tile[1] === b[index][1]);\n\nexport const indexOutOfRange = (board: Board, index: number) =>\n  index < 0 || index >= size(board);\n\nexport const canMoveTile = (\n  board: Board,\n  index: number,\n  emptyIndex: number,\n) => {\n  const tilePosition = board[index];\n  const emptyPosition = board[emptyIndex];\n\n  if (tilePosition[0] === emptyPosition[0]) {\n    return Math.abs(tilePosition[1] - emptyPosition[1]) === 1;\n  }\n\n  if (tilePosition[1] === emptyPosition[1]) {\n    return Math.abs(tilePosition[0] - emptyPosition[0]) === 1;\n  }\n\n  return false;\n};\n\nexport const moveTile = (board: Board, index: number, emptyIndex: number) => {\n  if (indexOutOfRange(board, index)) {\n    return board;\n  }\n\n  if (!canMoveTile(board, index, emptyIndex)) {\n    return board;\n  }\n\n  const tilePosition = [...board[index]] as BoardTile;\n  const emptyPosition = [...board[emptyIndex]] as BoardTile;\n\n  const newBoard = [...board];\n\n  newBoard[emptyIndex] = tilePosition;\n  newBoard[index] = emptyPosition;\n\n  return newBoard;\n};\n\nexport const calculatePosition = (\n  emptyTile: BoardTile,\n  direction: Direction,\n) => {\n  switch (direction) {\n    case Direction.UP:\n      return [emptyTile[0] + 1, emptyTile[1]];\n    case Direction.DOWN:\n      return [emptyTile[0] - 1, emptyTile[1]];\n    case Direction.LEFT:\n      return [emptyTile[0], emptyTile[1] + 1];\n    case Direction.RIGHT:\n      return [emptyTile[0], emptyTile[1] - 1];\n    default:\n      return emptyTile;\n  }\n};\n\nexport const getMovingTileIndex = (\n  board: Board,\n  direction: Direction,\n  emptyIndex: number,\n) => {\n  const emptyPosition = board[emptyIndex];\n\n  const positionToMove = calculatePosition(emptyPosition, direction);\n\n  for (let i = 0; i < size(board); i++) {\n    if (\n      board[i][0] === positionToMove[0] &&\n      board[i][1] === positionToMove[1]\n    ) {\n      return i;\n    }\n  }\n\n  return emptyIndex;\n};\n\nexport const isSolved = (board: Board, solvedBoard: Board) =>\n  areEqual(board, solvedBoard);\n","import React from 'react';\nimport { useMachine } from '@xstate/react/lib';\nimport BoardComponent from '../BoardComponent/BoardComponent';\nimport { getDirectionByKeyCode } from '../../utils';\nimport { createMachine } from '../../state';\n\nconst NUM_ROWS = 4;\nconst NUM_COLS = 4;\nconst TILE_SIZE = 100;\nconst GAP = 5;\nconst NUM_TILES = NUM_COLS * NUM_ROWS;\nconst EMPTY_INDEX = NUM_TILES - 1;\n\nconst gameMachine = createMachine(NUM_ROWS, NUM_COLS, EMPTY_INDEX);\n\nconst App = () => {\n  const [state, send] = useMachine(gameMachine);\n\n  const handleClick = React.useCallback(\n    (index: number) => {\n      send({ type: 'CLICK', index });\n    },\n    [send],\n  );\n\n  React.useEffect(() => {\n    const listener = (event: KeyboardEvent) => {\n      const direction = getDirectionByKeyCode(event.keyCode);\n      if (direction) {\n        send({ type: 'MOVE', direction });\n      }\n    };\n\n    window.addEventListener('keyup', listener);\n\n    return () => window.removeEventListener('keyup', listener);\n  }, [send]);\n\n  const board = state.matches('ready')\n    ? state.context.originalBoard\n    : state.context.board;\n\n  return (\n    <div className=\"game\">\n      <div className=\"game__header\">\n        {state.matches('unsolved') && <span>Moves: {state.context.moves}</span>}\n        {state.matches('solved') && <span>Congratulations!</span>}\n      </div>\n      <BoardComponent\n        rows={NUM_ROWS}\n        cols={NUM_COLS}\n        tileWidth={TILE_SIZE}\n        tileHeight={TILE_SIZE}\n        gap={GAP}\n        board={board}\n        onTileClick={handleClick}\n      />\n    </div>\n  );\n};\n\nexport default App;\n","import { Board, Direction } from '../interfaces';\nimport { assign, Machine, MachineConfig, MachineOptions } from 'xstate';\nimport * as game from '../services/game';\nimport { rand } from '../utils';\n\ninterface GameContext {\n  moves: number;\n  originalBoard: Board;\n  board: Board;\n  emptyIndex: number;\n}\n\ninterface GameSchema {\n  states: {\n    ready: {};\n    unsolved: {};\n    solved: {};\n  };\n}\n\ntype GameEvent =\n  | { type: 'START' }\n  | { type: 'MOVE'; direction: Direction }\n  | { type: 'CLICK'; index: number }\n  | { type: 'UNDO' };\n\nexport const createMachine = (\n  rows: number,\n  cols: number,\n  emptyIndex: number,\n) => {\n  const config: MachineConfig<GameContext, GameSchema, GameEvent> = {\n    key: 'game',\n    initial: 'ready',\n    context: {\n      moves: 0,\n      board: [],\n      originalBoard: game.createBoard(rows, cols),\n      emptyIndex: emptyIndex,\n    },\n    states: {\n      ready: {\n        on: {\n          '': {\n            target: 'unsolved',\n            actions: ['SHUFFLE'],\n          },\n        },\n      },\n      unsolved: {\n        on: {\n          MOVE: [\n            {\n              target: 'solved',\n              cond: 'isSolved',\n            },\n            {\n              target: 'unsolved',\n              internal: true,\n              actions: ['MOVE_BY_DIRECTION', 'INCREMENT_MOVES'],\n            },\n          ],\n          CLICK: [\n            {\n              target: 'solved',\n              cond: 'isSolved',\n            },\n            {\n              target: 'unsolved',\n              internal: true,\n              actions: ['MOVE_BY_INDEX', 'INCREMENT_MOVES'],\n            },\n          ],\n        },\n      },\n      solved: {\n        type: 'final',\n      },\n    },\n  };\n\n  const options: Partial<MachineOptions<GameContext, GameEvent>> = {\n    guards: {\n      isSolved: (context) =>\n        game.isSolved(context.board, context.originalBoard),\n    },\n    actions: {\n      SHUFFLE: assign({\n        board: (context) =>\n          game.shuffle(context.originalBoard, rand(60, 80), context.emptyIndex),\n      }),\n      MOVE_BY_DIRECTION: assign({\n        board: (context, event) => {\n          const index = game.getMovingTileIndex(\n            context.board,\n            // @ts-ignore\n            event.direction,\n            context.emptyIndex,\n          );\n          return game.moveTile(context.board, index, context.emptyIndex);\n        },\n      }),\n      MOVE_BY_INDEX: assign({\n        board: (context, event) => {\n          // @ts-ignore\n          return game.moveTile(context.board, event.index, context.emptyIndex);\n        },\n      }),\n      INCREMENT_MOVES: assign({\n        moves: (context) => context.moves + 1,\n      }),\n    },\n  };\n\n  return Machine<GameContext, GameSchema, GameEvent>(config, options);\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/App/App';\nimport * as serviceWorker from './serviceWorker';\n\nimport './index.scss';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}